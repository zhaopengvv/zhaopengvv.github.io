{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/24/hello-world/"},{"title":"高版本gcc编译出的程序在低版本glibc机器上运行报错","text":"高版本gcc编译出的程序在低版本glibc机器上运行报错在高版本的gcc编译器编译程序，在低版本的glibc机器上运行，报如下错误： 12/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15' 高版本GCC编译安装后的执行文件或动态库依赖高版本的GCC标准库。如果将编译结果移植到另一个同架构同系统的机子，则会运行失败。C++标准库一直存在的ABI不兼容问题，就是对同一个API，不同版本的标准库实现不同，导致在链接时失败。 有什么解决办法？ 静态编译是可以的 把依赖的低版本不兼容的库在编译时静态链接，比如 -static-libstdc++ -static-libgcc，会和代码一起编译进二进制文件里。如果依赖的不兼容的库比较多，会比较麻烦。另外也可能有开源风险。 将动态链接库一同发布 首先ldd二进制可执行文件，查看它依赖了哪些动态链接库（高版本机器上的libc、libstdc++），一起打包发布出去，运行时修改LD_LIBRARY_PATH，把你打包的库路径放在前面。 理清gcc、glibc、libstdc++的关系 gcc的全称是GNU Compiler Collection，它是一个能够编译多种语言的编译器。最开始gcc是作为C语言的编译器（GNU C Compiler），现在除了c语言，还支持C++、java、Pascal等语言，并且支持多种硬件平台。 glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。由于 glibc 囊括了几乎所有的 UNIX通行的标准，可以想见其内容包罗万象。而就像其他的 UNIX 系统一样，其内含的档案群分散于系统的树状目录结构中，像一个支架一般撑起整个操作系统。 libstdc++与gcc的关系就像clang与libc++，libc++是针对clang编译器特别重写的C++标准库，那libstdc++是GCC的C++标准库。 LIBRARY_PATH和LD_LIBRARY_PATHLIBRARY_PATH和LD_LIBRARY_PATH是Linux下的两个环境变量，二者的含义和作用分别如下： LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径，例如，指定gcc编译需要用到的动态链接库的目录。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）： 1export LIBRARY_PATH=LIBDIR1:LIBDIR2:$LIBRARY_PATH LD_LIBRARY_PATH环境变量用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径，注意，LD_LIBRARY_PATH中指定的路径会在系统默认路径之前进行查找。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）： 1export LD_LIBRARY_PATH=LIBDIR1:LIBDIR2:$LD_LIBRARY_PATH 程序加载运行时动态库的搜索路径的先后顺序是： 编译目标代码时指定的动态库搜索路径； 环境变量LD_LIBRARY_PATH指定的动态库搜索路径； 配置文件/etc/ld.so.conf中指定的动态库搜索路径； 默认的动态库搜索路径/lib和/usr/lib； 这个顺序是compile gcc时写在程序内的，通常软件源代码自带的动态库不会太多，而我们的/lib和/usr/lib只有root权限才可以修改，而且配置文件/etc/ld.so.conf也是root的事情，我们只好对LD_LIBRARY_PATH进行操作啦。","link":"/2023/09/24/%E9%AB%98%E7%89%88%E6%9C%ACgcc%E7%BC%96%E8%AF%91%E5%87%BA%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%A8%E4%BD%8E%E7%89%88%E6%9C%ACglibc%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/"}],"tags":[{"name":"gcc","slug":"gcc","link":"/tags/gcc/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"}]}