{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"hexo + github 搭建个人博客","text":"摘要：介绍hexo + github 搭建个人博客 环境搭建Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads 下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。 安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version 并回车查询版本号。 创建github仓库创建github仓库，仓库名称为用户名.github.io，博客地址为https://用户名.github.io。 注：用户名为github用户名。 本地安装hexo创建一个hexo的安装目录，打开该目录，git bush here。 使用 npm 一键安装 Hexo 博客程序： 1npm install -g hexo-cli 初始化并安装所需组件： 12hexo init # 初始化npm install # 安装组件 启动本地服务器进行预览： 12hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面。 部署 Hexo 到 GitHub Pages安装 hexo-deployer-git： 1npm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages。 完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 常用命令12345678hexo new &quot;name&quot; # 新建文章hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面hexo d # 部署hexo g -d # 生成页面并部署hexo s # 本地预览hexo clean # 清除缓存和已生成的静态文件hexo help # 帮助","link":"/2023/10/29/2023-10-29%20hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"PostgreSQL 14.3 源码安装","text":"摘要：介绍PostgreSQL 14.3 源码安装，postgresql使用和vscode源码调试。 1. 环境准备1.1 系统参数修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556systemctl status firewalld.service #查看防火状态systemctl stop firewalld.service #暂时关闭防火墙systemctl disable firewalld.service #永久关闭防火墙 setenforce 0 #临时关闭selinux防火墙, setenforce是Linux的selinux防火墙配置命令sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config #禁用SELinuxcat &gt; /etc/sysctl.conf &lt;&lt;&quot;EOF&quot;vm.swappiness=10 #访问交换内存比直接访问物理内存要慢得多, swappiness参数的较低值很可能会提高整体系统性能。vm.zone_reclaim_mode=0 #关闭zone_reclaim模式，可以从其他zone或NUMA节点回收内存fs.aio-max-nr = 1048576 #系统中所允许的异步IO请求最大数目fs.file-max = 6815744 #系统中所允许的文件句柄最大数目net.ipv4.ip_local_port_range = 9000 65500 #网络连接可用作其源（本地）端口的最小和最大端口的限制net.core.rmem_default = 262144 #套接字接收缓冲区大小的缺省值net.core.rmem_max = 4194304 #套接字接收缓冲区大小的最大值net.core.wmem_default = 262144 #套接字发送缓冲区大小的缺省值net.core.wmem_max = 1048586 #套接字发送缓冲区大小的最大值kernel.shmmax = 1288490188 #单个共享内存段的最大值kernel.shmall = 314572 #可用共享内存的总量,单位是页,一般此值与kernel.shmmax相等kernel.shmmni = 4096 #单个共享内存段的最小值kernel.sem = 50100 64128000 50100 1280 #用于控制内核信号量EOFsysctl -pcat &gt;&gt; /etc/security/limits.conf &lt;&lt;&quot;EOF&quot; * soft nofile 131072* hard nofile 131072* soft nproc 131072* hard nproc 131072* soft core unlimited* hard core unlimited* soft memlock 50000000* hard memlock 50000000EOFecho &quot;* - nproc unlimited&quot; &gt; /etc/security/limits.d/90-nproc.confecho &quot;session required pam_limits.so&quot; &gt;&gt; /etc/pam.d/login# 关闭THProot用户下在vi /etc/rc.local最后添加如下代码if test -f /sys/kernel/mm/transparent_hugepage/enabled; thenecho never &gt; /sys/kernel/mm/transparent_hugepage/enabledfiif test -f /sys/kernel/mm/transparent_hugepage/defrag; thenecho never &gt; /sys/kernel/mm/transparent_hugepage/defragfichmod +x /etc/rc.d/rc.localecho never &gt; /sys/kernel/mm/transparent_hugepage/enabledecho never &gt; /sys/kernel/mm/transparent_hugepage/defragcat /sys/kernel/mm/transparent_hugepage/enabledcat /sys/kernel/mm/transparent_hugepage/defrag 2. 源码安装2.1 下载源码包1下载源码包 wget https://ftp.postgresql.org/pub/source/v9.32/postgresql-9.2.tar.gz --no-check-certificate 2.2 安装依赖包1yum install -y cmake make gcc zlib zlib-devel gcc-c++ perl readline readline-devel \\ python36 tcl openssl ncurses-devel openldap pam flex readline (命令行编辑支持库) zlib (数据压缩支持库) flex (词法分析库) bison (语法分析库) 2.3 创建用户1234groupadd postgresuseradd postgresecho &quot;postgres&quot; | passwd --stdin postgreschown postgres.postgres /home/postgres/.bash_profile 2.4 创建目录1234## 创建目录mkdir -p /postgresql/{pgdata,archive,scripts,backup,pg14,soft}chown -R postgres:postgres /postgresqlchmod -R 775 /postgresql ​ pgdata：数据目录 ​ archive：归档目录 ​ backup：WAL目录 ​ pg14：安装文件目录 ​ soft：源文件目录 2.5 编译安装12345678910111213-- 编译su - postgrescd /postgresql/softtar zxvf postgresql-14.3.tar.gzcd postgresql-14.3./configure --prefix=/postgresql/pg14#或增加调试#./configure --prefix=/postgresql/pg14 --enable-depend --enable-debug --enable-cassert CFLAGS=-O0make -j 64 &amp;&amp; make install如果希望编译所有能编译的东西，包括文档（HTML和手册页）以及附加模块（contrib），这样键入：make world -j 16 &amp;&amp; make install-world 1sudo /sbin/ldconfig /postgresql/pg14/lib 2.6 配置环境变量1234567891011-- 配置环境变量cat &gt;&gt; $HOME/.bash_profile &lt;&lt;&quot;EOF&quot;export PGPORT=5432export PGDATA=/postgresql/pgdataexport PGHOME=/postgresql/pg14export LD_LIBRARY_PATH=$PGHOME/lib:$LD_LIBRARY_PATHexport PATH=$PGHOME/bin:$PATH:.export PGHOST=$PGDATAexport PGUSER=postgresexport PGDATABASE=postgresEOF 1source $HOME/.bash_profile 2.7 初始化数据库12-- 初始化/postgresql/pg14/bin/initdb -D /postgresql/pgdata -E UTF8 --locale=en_US.utf8 -U postgres 2.8 修改参数12345678910-- 修改参数cat &gt;&gt; /postgresql/pgdata/postgresql.conf &lt;&lt;&quot;EOF&quot;listen_addresses = '*'port=5432unix_socket_directories='/postgresql/pgdata'logging_collector = onlog_directory = 'pg_log'log_filename = 'postgresql-%a.log'log_truncate_on_rotation = onEOF 2.9 启动数据库12345-- 启动pg_ctl startpg_ctl statuspg_ctl stoppg_ctl stop -m fast 3. 连接数据库12345su - postgrespsql -p 5432 -h 127.0.0.1;// 更改数据库密码alter user postgres with password 'postgres'; 4. 安装插件123456-- 安装插件create extension pageinspect;create extension pg_stat_statements;select * from pg_extension;select * from pg_available_extensions order by name; ​ 安装PG数据库时，会建立一个与初始化数据库时的操作系统用户名同名的数据库用户，同时，这个用户是数据库的超级用户，在这OS用户下登录数据库使用的是操作系统认证，所以不需要用户名和密码。也可以通过修改pg_hba.conf文件要求输入密码。 12345cat &gt; /postgresql/pgdata/pg_hba.conf &lt;&lt; EOF# TYPE DATABASE USER ADDRESS METHODhost all all 0.0.0.0/0 md5EOF 4. 错误处理4.1 socket链接错误123[postgres@iZuf6ddpzz3ipktm5kj01cZ pgdata]$ psql psql: error: connection to server on socket &quot;/postgresql/pgdata/.s.PGSQL.5433&quot; failed: FATAL: no pg_hba.conf entry for host &quot;[local]&quot;, user &quot;postgres&quot;, database &quot;postgres&quot;, no encryption 指定postgresql的ip地址和端口号 1psql -p 5433 -h 47.103.xxx.xxx; 4.2 连接postgres服务端忘记密码123[postgres@iZuf6ddpzz3ipktm5kj01cZ ~]$ psql -p 5433 -h 47.103.136.252;Password for user postgres: psql: error: connection to server at &quot;47.103.136.252&quot;, port 5433 failed: FATAL: password authentication failed for user &quot;postgres&quot; ​ 修改/postgresql/pgdata/pg_hba.conf的METHOD字段为trust 12# TYPE DATABASE USER ADDRESS METHODhost all all 0.0.0.0/0 trust ​ 重新设置密码 123postgres=# \\passwordEnter new password: Enter it again: 重启服务器 1pg_ctl reload 5. vscode源码调试​ 在launch.json中添加新的配置，一共有三个例子，一个postgres –help，一个initdb，一个postgres后端调试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;postgres --help&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;/postgresql/pg14/bin/postgres&quot;, &quot;args&quot;: [ &quot;--help&quot; ], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerArgs&quot;: &quot;--command=/home/postgres/cmd.gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] }, { &quot;name&quot;: &quot;initdb&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;/postgresql/pg14/bin/initdb&quot;, &quot;args&quot;: [ &quot;-D&quot;, &quot;&lt;datadir&gt;&quot; ], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerArgs&quot;: &quot;--command=/home/postgres/cmd.gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] }, { &quot;name&quot;: &quot;postgres backend&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;program&quot;: &quot;/postgresql/pg14/bin/postgres&quot;, &quot;processId&quot;: &quot;${command:pickProcess}&quot;, &quot;stopAtEntry&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerArgs&quot;: &quot;--command=/home/postgres/cmd.gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] } ]} ​ 创建/home/postgres/cmd.gdb文件，写入文件内容 12345set print element 0set print object onset prin vtbl onset print pretty onhand SIGUSR1 SIGUSR2 SIG36 SIGSTOP noprint nostop ​ 在exec_simple_query函数打断点，然后在侧边栏Run and Debug中选择postgres backend，点击调试按钮或者按F5后，输入postgres，选择postgres db xxxx idle进程。 6. 参考https://cloud.tencent.com/developer/article/2013907","link":"/2023/09/24/PostgreSQL%2014.3%20%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"},{"title":"","text":"","link":"/2023/11/02/Untitled/"},{"title":"WSL安装指南","text":"摘要：介绍WSL安装流程 1. 开启WSL支持​ 按 Win+X, 找到 Windows PowerShell (管理员)，并复制执行命令。该命令会激活 WSL 服务，然后需要重启系统。 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux ​ 重启之后，Win + R，输入 appwiz.cpl，左上角找到“启动或关闭 Windows 功能”，会看到这个选项处于选中状态。其实吧，上面的命令就相当于手动去勾选这个功能。直接命令执行效率可能更高些。 2. 安装WSL发行版本​ 在 Windows 应用商店搜索 ubuntu ，选择自己喜欢的版本，安装即可。 ​ 这里我选择的是 Ubuntu 20.04 LTS，之后的所有内容也是基于 WSL Ubuntu 编写。 ​ 下载，安装之后，第一次打开会初始化一会 ​ 然后设置个用户名，密码 ​ ​ 到这里，其实咱们的 WSL 就安装好了。 ​ 接下来我们让它更好用吧！ 3. apt换源​ Debian / Ubuntu 的官方源在国内访问很慢，咱们更换为清华大学 TUNA 的软件源镜像 ​ 执行下面命令，备份 apt 安装源： 1$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak ​ vim 编辑 sources.list ： 1sudo vim /etc/apt/sources.list ​ 将 sources.list 中的内容替换如下： 1 4. 更新软件 更新软件源中的所有软件列表，可以看到飞快的在刷屏，哗哗哗的 1$ sudo apt-get update 更新软件 12$ sudo apt-get upgrade# 更新内容稍多，差不多几分钟，玩会手机吧。。。 5. 配置SSH服务器​ 咱们用惯了 类似 xshell ，SecureCRT 这种 SSH 工具连接 Linux，所以顺便把 SSH 功能打通吧，用的顺手，毕竟 PowerShell 用的不是太方便！ ​ WSL 上的 SSH 服务器没有自动配置，需要手动重新安装，首先可以运行以下命令来检查 12$ sudo service ssh stop$ sudo /usr/sbin/sshd -d ​ 如果输出信息包括以上信息，即找不到 key，重新安装 openssh-server 就可以解决问题 12$ sudo apt purge openssh-server$ sudo apt install openssh-server ​ 然后需要配置 /etc/ssh/sshd_config，用 sudo 权限运行 vim 修改如下三个关键字 ​ 记得删除 # 1234Port 22# 这两行允许了 root 账户和密码登录PermitRootLogin yesPasswordAuthentication yes ​ 然后记得重启 ssh 服务 12$ sudo service ssh restart$ sudo service ssh status ​ 如果需要用密码登录 root 账户，还需要设置密码 1$ sudo passwd root ​ 然后就可以使用 SSH 工具进行连接啦，本地直接 localhost 即可","link":"/2023/09/24/WSL%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/24/hello-world/"},{"title":"mysql 获取表锁 LOCK TABLES","text":"语法： 12345678910LOCK TABLES tbl_name [[AS] alias] lock_type [, tbl_name [[AS] alias] lock_type] ...lock_type: { READ [LOCAL] | [LOW_PRIORITY] WRITE}UNLOCK TABLES ​ READ [LOCAL] lock： 当前会话获取表的读锁，该锁只能读表，不能写表； 多个会话可以同时获取表的读锁； 其他会话可以在不显式获取read锁的情况下读取表； LOCAL修饰符允许其他会话在持有锁时执行无冲突的INSERT语句(并发插入)。 但是，如果要在持有锁的同时使用服务器外部的进程操作数据库，则不能使用READ LOCAL。 对于InnoDB表，READ LOCAL和READ是一样的。 ​ [LOW_PRIORITY] WRITE lock： 当前会话获取表的写锁，该锁可以读写表； 只有获取锁的会话才能访问表，在锁被释放之前，没有其他会话可以访问它； 当WRITE锁被持有时，其他会话阻塞对表的锁请求； OW_PRIORITY修饰符没有作用。 在MySQL的早期版本中，它会影响锁定行为，但现在不再是这样了。 它现在已被弃用，使用它会产生一个警告。 使用不带LOW_PRIORITY的WRITE代替。 ​ WRITE锁通常比READ锁具有更高的优先级，以确保尽快处理更新。 如果一个会话获得了一个READ锁，然后另一个会话请求了一个WRITE锁，那么READ锁请求将等待，直到请求WRITE锁的会话获得了锁并释放它。 ​ 需要锁的会话必须在单个LOCK TABLES语句中获取所需的所有锁。 当这样获得的锁被持有时，会话只能访问被锁定的表，不能访问其他未被加锁的表。INFORMATION_SCHEMA数据库中的表是个例外。 即使会话持有通过LOCK TABLES获得的表锁，也可以在不显式锁定的情况下访问它们。 ​ 在单个查询中，不能使用相同的名称多次引用锁定表。 使用别名代替，为表和每个别名获得一个单独的锁: 1234mysql&gt; LOCK TABLE t WRITE, t AS t1 READ;mysql&gt; INSERT INTO t SELECT * FROM t;ERROR 1100: Table 't' was not locked with LOCK TABLESmysql&gt; INSERT INTO t SELECT * FROM t AS t1; 第一次INSERT会出现错误，因为对一个锁定的表有两个对相同名称的引用。 第二次INSERT成功，因为对表的引用使用了不同的名称。 ​ 当会话持有的表锁被释放时，它们将同时被释放。 会话可以显式释放锁，也可以在特定条件下隐式释放锁。 会话可以使用UNLOCK TABLES显式释放其锁。- 如果一个会话在已经持有锁的情况下发出LOCK TABLES语句来获取锁，那么在授予新锁之前，它的现有锁将隐式释放。 如果会话开始一个事务(例如，使用START transaction)，则执行隐式的UNLOCK TABLES，这将导致释放现有的锁。 ​ LOCK TABLES和UNLOCK TABLES不能在存储程序中使用。 ​ 当LOCK TABLES语句生效时，禁止执行以下语句:CREATE TABLE, CREATE TABLE… 存储函数、过程和事件上的LIKE、CREATE VIEW、DROP VIEW和DDL语句。 ​ 在一些情况下，锁表可能会提供一个优势: 如果要在一组MyISAM表上运行许多操作，那么锁定将要使用的表要快得多。 锁定MyISAM表可以加快对表的插入、更新和删除，因为MySQL在调用UNLOCK tables之前不会刷新被锁定表的key cache。 通常，在每个SQL语句之后刷key cache。 锁定表的缺点是，没有会话可以更新一个read -lock的表(包括持有锁的表)，没有会话可以访问一个write -lock的表，除了持有锁的表。 如果您正在为非事务性存储引擎使用表，如果您希望确保在SELECT和UPDATE之间没有其他会话修改表，则必须使用LOCK tables。 下面的例子需要LOCK TABLES安全地执行: 123456LOCK TABLES trans READ, customer WRITE;SELECT SUM(value) FROM trans WHERE customer_id=some_id;UPDATE customer SET total_value=sum_from_previous_statement WHERE customer_id=some_id;UNLOCK TABLES; 如果没有LOCK TABLES，另一个会话可能会在执行SELECT和UPDATE语句之间在transtable中插入新行。","link":"/2023/09/27/mysql%20%E8%A1%A8%E9%94%81/"},{"title":"postgreSQL中的TOAST技术","text":"摘要：介绍postgreSQL中的TOAST技术 ​ TOAST（The Oversize-Attribute Storage Technique）技术是PG提供的一种存储大数据的机制。 ​ 要理解TOAST，我们要先理解页（BLOCK）的概念。在PG中，页是数据在文件存储中的基本单位，其大小是固定的且只能在编译期指定，之后无法修改，默认的大小为8KB。同时，PG不允许一行数据跨页存储。那么对于超长的行数据，PG就会启动TOAST，将大的字段压缩或切片成多个物理行存到另一张系统表中（TOAST表），这种存储方式叫行外存储。 ​ 在PostgreSQL中只有具有变长行为的数据类型（代码内部常称为varlena类型）才支持TOAST，比如TEXT数据类型。在向支持TOAST的属性中存储超过BLCKSZ/4字节（通常是2K）的数据时，TOAST机制才会被触发。在变长数据类型中，数值的前两位表示数值的存储方式： 如果是00，该数值是普通的未TOAST的数值。 如果是01，表示该数据被压缩过，剩下30位表示压缩后的数据大小，在这4字节之后还会附加4字节，表示未压缩的数据大小。 如果是1x，数据头部仅用一字节。当存储的是短字符串（小于128字节），剩下7位表示字符串长度。当该字节为10000000时，表明这是线外存储的数据，紧随其后使用1字节记录指针大小，数据区域记录TOAST指针。 注意：线外存储时，也可能进行压缩，这种情况通过TOAST指针中的va_rawsize和va_extsize来进行比较。？？？？ ​ 线外存储的数据会保存在称为TOAST表的普通表中。如果一个表中有一个属性是可TOAST的，那么该表将会有一个可关联的TOAST表，其OID存储在表的基本信息（也就是pg_class中的元组）的reltoastrelid属性中。如果没有关联的TOAST表，reltoastrelid属性为0。 ​ TOAST机制有四种不同的存储策略（表中的Storage属性）： PLAN：避免压缩或者线外存储。不支持toast的数据类型 EXTENDED：允许压缩和线外存储，大多数可TOAST的数据类型的缺省值。 EXTERNAL：允许线外存储但是不允许压缩。可以使text和bytea字段上的字串操作更快。 MAIN：允许压缩，但是不允许线外存储。实际上这样的数据类型仍然可以进行线外存储。 存储策略可以使用ALTER TABLE SET STORAGE语句修改。 12345678910db=&gt; create table t1 (c1 int, c2 text, c3 bytea);CREATE TABLEdb=&gt; \\d+ t1 Table &quot;public.t1&quot; Column | Type | Collation | Nullable | Default | Storage | Compression | Stats target | Description --------+---------+-----------+----------+---------+----------+-------------+--------------+------------- c1 | integer | | | | plain | | | c2 | text | | | | extended | | | c3 | bytea | | | | extended | | | Access method: heap 1234567891011db=&gt; select relname, reltoastrelid from pg_class where relname = 't1'; relname | reltoastrelid ---------+--------------- t1 | 32785(1 row)db=&gt; select relname, relnamespace from pg_class where oid = '32785'; relname | relnamespace ----------------+-------------- pg_toast_32782 | 99(1 row) 1234567891011121314151617-- pg_toast_32777的命名空间db=&gt; select nspname from pg_namespace where oid = 99;-[ RECORD 1 ]-----nspname | pg_toast--TOAST表的定义db=&gt; \\d+ pg_toast.pg_toast_32777TOAST table &quot;pg_toast.pg_toast_32777&quot; Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plainOwning table: &quot;public.t1&quot;Indexes: &quot;pg_toast_32777_index&quot; PRIMARY KEY, btree (chunk_id, chunk_seq)Access method: heap TOAST表有三个字段： chunk_id ：用来表示特定 TOAST 值的 OID ，可以理解为具有同样 chunk_id 值的所有行组成原表的 TOAST 字段的一行数据。 chunk_seq： 用来表示该行数据在整个数据中的位置。 chunk_data ： 该Chunk实际的数据。 对应的TOAST表的数据结构： 123456789 */typedef struct varatt_external{ int32 va_rawsize; /* Original data size (includes header) */ uint32 va_extinfo; /* External saved size (without header) and * compression method */ Oid va_valueid; /* Unique ID of value within TOAST table */ Oid va_toastrelid; /* RelID of TOAST table containing it */} varatt_external; 探究TOAST机制 ​ c2只有10个字符，所以没有压缩，也没有行外存储。然后我们使用如下 SQL 语句增加 c2的长度，每次增长1倍，同时观察 c2的长度。 123456789101112db=&gt; insert into t1 values(1, 'title', '0123456789'); INSERT 0 1 db=&gt; select * from t1; c1 | c2 | c3 ----+-------+------------------------ 1 | title | \\x30313233343536373839(1 row)db=&gt; select * from pg_toast.pg_toast_32782; chunk_id | chunk_seq | chunk_data ----------+-----------+------------(0 rows) ​ 反复执行如上过程，直到 pg_toast_32782表中有数据。直到 content 的长度为327680时（已远远超过页大小 8K），对应 TOAST 表中才有了数据，且长度都是略小于2K，这是因为 extended 策略下，先启用了压缩，然后才使用行外存储。 12345678910111213141516171819202122232425262728293031323334353637383940db=&gt; update t1 set c2=c2||c2 where c1=1;UPDATE 1.....db=&gt; select c1, length(c2) from t1; c1 | length ----+---------- 1 | 83886080(1 row)db=&gt; select * from pg_toast.pg_toast_32782;-[ RECORD 1 ]-----------------------------------------------------------------------------------------------chunk_id | 32795chunk_seq | 0chunk_data | .....-[ RECORD 2 ]-----------------------------------------------------------------------------------------------chunk_id | 32795chunk_seq | 1chunk_data | .....-[ RECORD 3 ]-----------------------------------------------------------------------------------------------chunk_id | 32795chunk_seq | 2chunk_data | .....db=&gt; select chunk_id,chunk_seq,length(chunk_data) from pg_toast.pg_toast_32782; chunk_id | chunk_seq | length ----------+-----------+-------- 32795 | 0 | 1996 32795 | 1 | 1996 32795 | 2 | 1996 32795 | 3 | 1996 32795 | 4 | 1996 32795 | 5 | 1996 32795 | 6 | 1996 32795 | 7 | 1996 32795 | 8 | 1996 32795 | 9 | 1996 32795 | 10 | 1996 32795 | 11 | 1996 32795 | 12 | 1996 参考：https://zhuanlan.zhihu.com/p/142281841","link":"/2023/10/29/postgreSQL%E4%B8%AD%E7%9A%84TOAST%E6%8A%80%E6%9C%AF/"},{"title":"计划共享内存","text":"摘要：计划总结共享内存知识 TODO。 共享内存的介绍共享内存的使用共享内存实战共享内存安全（进程间同步）参考：https://www.cnblogs.com/52php/p/5861372.htm","link":"/2023/10/29/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BB%8B%E7%BB%8D/"},{"title":"高版本gcc编译出的程序在低版本glibc机器上运行报错","text":"在高版本的gcc编译器编译程序，在低版本的glibc机器上运行，报如下错误： 12/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15' 高版本GCC编译安装后的执行文件或动态库依赖高版本的GCC标准库。如果将编译结果移植到另一个同架构同系统的机子，则会运行失败。C++标准库一直存在的ABI不兼容问题，就是对同一个API，不同版本的标准库实现不同，导致在链接时失败。 有什么解决办法？ 静态编译是可以的 把依赖的低版本不兼容的库在编译时静态链接，比如 -static-libstdc++ -static-libgcc，会和代码一起编译进二进制文件里。如果依赖的不兼容的库比较多，会比较麻烦。另外也可能有开源风险。 将动态链接库一同发布 首先ldd二进制可执行文件，查看它依赖了哪些动态链接库（高版本机器上的libc、libstdc++），一起打包发布出去，运行时修改LD_LIBRARY_PATH，把你打包的库路径放在前面。 理清gcc、glibc、libstdc++的关系 gcc的全称是GNU Compiler Collection，它是一个能够编译多种语言的编译器。最开始gcc是作为C语言的编译器（GNU C Compiler），现在除了c语言，还支持C++、java、Pascal等语言，并且支持多种硬件平台。 glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。由于 glibc 囊括了几乎所有的 UNIX通行的标准，可以想见其内容包罗万象。而就像其他的 UNIX 系统一样，其内含的档案群分散于系统的树状目录结构中，像一个支架一般撑起整个操作系统。 libstdc++与gcc的关系就像clang与libc++，libc++是针对clang编译器特别重写的C++标准库，那libstdc++是GCC的C++标准库。 LIBRARY_PATH和LD_LIBRARY_PATHLIBRARY_PATH和LD_LIBRARY_PATH是Linux下的两个环境变量，二者的含义和作用分别如下： LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径，例如，指定gcc编译需要用到的动态链接库的目录。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）： 1export LIBRARY_PATH=LIBDIR1:LIBDIR2:$LIBRARY_PATH LD_LIBRARY_PATH环境变量用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径，注意，LD_LIBRARY_PATH中指定的路径会在系统默认路径之前进行查找。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）： 1export LD_LIBRARY_PATH=LIBDIR1:LIBDIR2:$LD_LIBRARY_PATH 程序加载运行时动态库的搜索路径的先后顺序是： 编译目标代码时指定的动态库搜索路径； 环境变量LD_LIBRARY_PATH指定的动态库搜索路径； 配置文件/etc/ld.so.conf中指定的动态库搜索路径； 默认的动态库搜索路径/lib和/usr/lib； 这个顺序是compile gcc时写在程序内的，通常软件源代码自带的动态库不会太多，而我们的/lib和/usr/lib只有root权限才可以修改，而且配置文件/etc/ld.so.conf也是root的事情，我们只好对LD_LIBRARY_PATH进行操作啦。","link":"/2023/09/24/%E9%AB%98%E7%89%88%E6%9C%ACgcc%E7%BC%96%E8%AF%91%E5%87%BA%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%A8%E4%BD%8E%E7%89%88%E6%9C%ACglibc%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/"}],"tags":[{"name":"postgres","slug":"postgres","link":"/tags/postgres/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"gcc","slug":"gcc","link":"/tags/gcc/"}],"categories":[{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"blog","slug":"blog","link":"/categories/blog/"}]}